# 2). Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
#
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
#     Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
#
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.
# Пример работы программ:
#
# sieve(2)
# 3
# prime(4)
# 7
# sieve(5)
# 11
# prime(1)
# 2

import timeit
import cProfile
import sys

# Второй — без использования «Решета Эратосфена».

# user_n = int(input('n='))


def prime(user_n):

    count = 4
    result = None

    while True:
        if user_n == 1:
            return 2
        elif user_n == 2:
            return 3
        elif user_n == 3:
            return 5
        elif user_n == 4:
            return 7
        else:
            for i in range(10, sys.maxsize, 1):
                spam_count = 0
                for d in range(2, i):
                    if i % d == 0:
                        spam_count += 1
                        if spam_count != 0:
                            break
                if spam_count == 0:
                    count += 1
                    if count == user_n:
                        result = i
                        break
        break
    return result


# Раскоментируй код для ручного ввода если есть желание.

user_n = int(input('Введите номер i-го по счёту простого числа - '))

print('Гавнокодерский способ №1. Был способ со списком решил я сумничать и без списка, наговнокодил, а взад править'
      'не успиваю поэтому пусть останиться как есть. До пяницы смены посему все дз необходимо сделать за вечер\n')

prime_test = prime(user_n)

print(f'Искомое число {prime_test}')

# print(timeit.timeit('prime(10)', globals=globals(), number=100))  # 0.0014236000000000006
#
# print(timeit.timeit('prime(100)', globals=globals(), number=100))  # 0.14321129999999999
#
# print(timeit.timeit('prime(1000)', globals=globals(), number=100))  # 35.0937505
#
# cProfile.run('prime(10)')
# # 1    0.000    0.000    0.000    0.000 HW_4_2.py:30(prime)
# cProfile.run('prime(100)')
# # 1    0.001    0.001    0.001    0.001 HW_4_2.py:30(prime)
# cProfile.run('prime(1000)')
# # 1    0.355    0.355    0.355    0.355 HW_4_2.py:30(prime)


# Первый — с помощью алгоритма «Решето Эратосфена».

def sieve(user_n):
    n = 300000

    sieve = [i for i in range(n)]  # только для текущей задачи, а не для ПЗ к уроку 2
    sieve[1] = 0

    for i in range(2, n):
        if sieve[i] != 0:
            j = i + i
            while j < n:
                sieve[j] = 0
                j += i

    # print(sieve)
    res = [i for i in sieve if i != 0]
    # print(res)

    return res[user_n - 1]


sieve_test = sieve(user_n)

print('Решетоэротосфенский способ №2. =(\n')

print(f'Искомое число {sieve_test}')

# print(timeit.timeit('sieve(10)', globals=globals(), number=100))  # 15.260252300000001
#
# print(timeit.timeit('sieve(100)', globals=globals(), number=100))  # 15.142236800000003
#
# print(timeit.timeit('sieve(1000)', globals=globals(), number=100))  # 15.141349700000006
#
# print(timeit.timeit('sieve(10000)', globals=globals(), number=100))  # 15.1149196
#
# cProfile.run('sieve(10)')
# # 1    0.125    0.125    0.149    0.149 HW_4_2.py:88(sieve)
# cProfile.run('sieve(100)')
# # 1    0.132    0.132    0.156    0.156 HW_4_2.py:88(sieve)
# cProfile.run('sieve(1000)')
# # 1    0.127    0.127    0.151    0.151 HW_4_2.py:88(sieve)
# cProfile.run('sieve(10000)')
# # 1    0.130    0.130    0.153    0.153 HW_4_2.py:88(sieve)

# --------------------------------------------------------------------------------------------------------------------


# Вывод:
# Из сего видно что вариант №1 гавнокодерский и имеет усложениение O(n^z) быстр и резок в начале, но глуп и медленен
# в оприрациях с большими числами. Вариант с промежуточным списком был молниеносен, я посчитал его не интересным,
# но интересный и правильный так и не придумал, а взад переписать не успиваю. =(

# Второй способ долго думает из за необходимости все время генерировать список, было дело вынес список из функции
# но после решил что если есть обращение то должна быть и генерация списка-решета ибо ситуация боевая при условии
# что эратосфен все время теряет свои таблички
# Усложнение тут линейное, работает хорошо и стабильно, но надо подгонять длину решета под искомые числа, увелечние
# диапазона многократно усложняет процесс
